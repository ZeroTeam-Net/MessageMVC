﻿﻿﻿# IMessageReceiver作为消息接收对象的高度抽象,它是一种规范和约束# 接受IService的控制反转-  IService.Initialize> 通过构造器(ApiDiscover发现时生成)构造出**IMessageReceiver**对象,并调用**IMessageReceiver.Initialize**方法,默认实现为什么也不做- IService.Start> 调用IMessageReceiver.Prepare方法,以进行一个轮询前的准备工作,如果准备成功,异步运行Run方法,- IService.Run> 在Start方法中异步运行,会依次调用IMessageReceiver.LoopBegin/Loop/LoopComplete方法- IService.Close> 接收关闭通知,调用CancelToken.Cancel方法,IMessageReceiver.Loop应同步响应.- IService.End> 调用IMessageReceiver.Close,以进行环境清理# 接受ApiExecuter的控制反转#### Commit方法> 当ApiExecuter接收到消息时调用1. 消息队列可考虑此进行ACK确认2. 异步RPC调用,可返回客户端,表示已接收#### OnResult方法> 当ApiExecuter执行完成一个方法时调用1. 消息队列可以调用Commit进行ACK确认2. RPC对象可以向客户端发送返回值#### OnError方法> 当ApiExecuter执行发生未处理异常时调用,它与OnResult只可能调用一次.1. 消息队列可以记录错误消息2. RPC对象可以向客户端发送异常返回值# Loop消息轮询1. 当接收到消息时,应解包后还原为IMessageItem对象,之后调用MessageProcessor.OnMessagePush方法,进入IMessageMiddleware的处理调用链中进行处理.2. 当CancelToken.Cancel调用时,应进行退出处理.3. 出现网络等问题时,应该自我恢复.# ApiDiscover 控制器依赖发现- ConsumerAttribute> 对应到 IMessageConsumer ,此时应保证正确注册过IMessageConsumer的实现,以便进行依赖构造.IMessageConsumer应为某种消息队列的实现- ServiceAttribute> 对应到 IRpcTransport ,此时应保证正确注册过IRpcTransport的实现,以便进行依赖构造.IRpcTransport应为RPC远程调用的实现- NetEventAttribute> 对应到 INetEvent ,此时应保证正确注册过INetEvent的实现,以便进行依赖构造.INetEvent应为实现了消息广播功能的组件,比如Kafka或ZMQ- ITransportDiscover> 为更方便灵活地通过属性或其它特征正确的构造消息接收对象,可通过实现并向依赖(IocHelper)注册这个接口,ApiDiscover会构造并使用它