﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿#   一 IFlowMiddleware流程中间件## 1 ConfigMiddleware实现配置读取与更新流程，此中间件为系统支持组件，会在内部自动注册且不可访问。## 2 ReConsumerMiddleware实现重新消费未正确处理消息的中间件,Flow实现了重启后重新本地消费#### 配置|节点|名称|默认|说明||:-:|:-|:-|:-||ZeroApp|EnableMessageReConsumer|false|启用消息存储与异常消息重新消费|## 3 KafkaPosterKafka消息发布对象，同时实现了IFlowMiddleware,以便全局初始化与析构Confluent.Kafka的IProducer对象,用于所有Kafka的消息发送。## 4 CsRedisPosterRedis生产者，同时实现了IFlowMiddleware，以便全局启动与关闭后台发送服务，内部通过信号触发后台发送，可以实现纯异步可靠发送。##  5 ZeroMQ.Inporc.ZmqFlowMiddleware在进程内通讯组件中实现ZMQ环境初始化与析构。##  6 ZeroRpcFlow实现ZeroRPC环境初始化与析构。内部实现了与ZeroCenter服务中心交互的相关细节。可实现服务注册、服务发现、负载均衡等微服务功能。##  7 ZeroPostProxy实现ZeroRPC远程异步调用的细节。##  7 AddInImporter基于MEF实现插件功能，通过在程序集中实现可IAutoRegister接口并实现为从而实现能力自注册.```csharpusing System.ComponentModel.Composition;using Agebull.Common.Ioc;using Microsoft.Extensions.DependencyInjection;namespace ZeroTeam.MessageMVC.AddIn{    /// <summary>    ///   组件注册    /// </summary>    [Export(typeof(IAutoRegister))]    [ExportMetadata("Symbol", '%')]    public sealed class AutoRegister : IAutoRegister    {        /// <summary>        /// 注册        /// </summary>        void IAutoRegister.AutoRegist(IServiceCollection service)        {            service.AddSingleton<ITester, HttpTester>();        }        /// <summary>        /// 初始化        /// </summary>        void IAutoRegister.Initialize()        {            IocHelper.ServiceCollection.AddSingleton<Tester, HttpTester>();        }    }}``` #  二 IMessageMiddleware消息处理中间件##  1 GlobalContextMiddlewareGlobalContext上下文对象处理中间件，在API执行前准备GlobalContext.Current对象,以便后续使用。> ZeroApp.EnableLinkTrace必须配置为true,默认不启用##  2 LoggerMiddleware日志处理中间件，向标准日志记录器输出IO跟踪日志。#### 配置|节点|名称|默认|说明||:-:|:-|:-|:-||ZeroApp|EnableMonitorLog|false|启用日志中间件||Logging|monitor|false|是否启动日志跟踪模式||Logging.LogLevel|Default||<=Information|##  3 MarkPointMiddleware埋点发出中间件，在其它下层中间件执行结束后，向配置的MarkPointName服务发送消息内容。#### 配置|节点|名称|默认|说明||:-:|:-|:-|:-||ZeroApp|EnableMarkPoint|false|启用埋点中间件||ZeroApp|MarkPointName||埋点服务名称||MessagePoster|[IMessagePoster名称]||埋点服务名称与传输协议绑定配置,如系统有配置默认协议,也可以不设置,会通过默认协议发出|## 4 ReverseProxyMiddleware 反向代理中间件,通过查找消息投递对象表,向此服务发送请求并返回服务,从而实现反向代理,可用于实现网关等需求。需要手动注册```csharperIocHelper.AddSingleton<IMessageMiddleware, ReverseProxyMiddleware>();```##  5 StorageMiddleware消息存储中间件,在消息处理前保存消息内容到文件,消息处理成功(即message.State == MessageState.Success)后删除文件#### 配置|节点|名称|默认|说明||:-:|:-|:-|:-||ZeroApp|EnableMessageReConsumer|false|启用消息存储与异常消息重新消费|##  6 ApiExecuterApi调用器,系统最重要中间件,没有之一。MVC功能的主要支持组件，实现Api路由，运行时调用API并返回结果。> 仅ApiExecuter与ReverseProxyMiddleware会调用IMessageReceiver对象的OnMessageError与OnMessageResult触发消息处理结果网络返回.##  7 WebSocketNotify转发消息到WebSocket.###  配置|节点|名称|默认|说明||:-:|:-|:-|:-||WebSocket|Folders||使用WebSocket的文件夹|###  Strat.cs1.  注册中间件2.  WebSocketNotify.Binding 绑定与WebSocket的关联，内部会按文件夹名作为服务名称，通过构造IMessageConsumer向ZeroFlowControl注册消息接收服务3.  启动ZFlowControl,如此处的UseFlow```csharperpublic void Configure(IApplicationBuilder app, IWebHostEnvironment env){   Services.AddTransient<IMessageMiddleware, WebSocketNotify>();    WebSocketNotify.Binding(app);    Services.UseFlow();}```# IMessagePoster> 消息投递器|对象|网络格式|说明||:-:|:-:|:-||InporcProducer|ZMQ进程内|采用ZMQ进程内通讯||HttpPoster|Http|基于IHttpClientFactory实现||KafkaPoster|Kafka|基于Kafka消息队列||CsRedisPoster|Redis|基于Redis的ZSet与PUBSUB实现高可用的简单队列||ZeroRPCPoster|ZMQ|基于ZMQ的RPC实现|# IMessageReceiver> 消息接收对象|对象|网络格式|类型|说明||:-:|:-:|:-||HttpTransfer|Http|IRpcTransfer|Http进站出站的处理类||KafkaConsumer|Kafka|IMessageConsumer|Kafka消息队列消费者||CSRedisConsumer|Redis|IMessageConsumer, INetEvent|RedisMQ消费者||InporcConsumer|ZMQ|IMessageConsumer|ZMQ进程内通讯消费端||ZeroRpcTransport|ZMQ|IRpcTransfer|ZMQRpc消费端|